<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Porting Reach to a New Chip &#8212; Cygnus Reach Embedded Stack  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="porting-reach-to-a-new-chip">
<h1>Porting Reach to a New Chip<a class="headerlink" href="#porting-reach-to-a-new-chip" title="Link to this heading">¶</a></h1>
<p>November, 2025	Chuck Peplinski	version 3</p>
<p>The original Reach version was built in the SiLabs ecosystem. It was soon after ported to the Nordic ecosystem where it is used by the Trico project. The SiLabs port is “bare metal,” in that there is no RTOS. It focuses on being as small as possible to prove its viability in small memory systems. But this is just one possible constraint. Other environments have different constraints. We have recently ported Reach to two new chips, namely the Microchip PIC32WM_BZ6204 (“BZ6”) and the RealTek BW16 (AmebaD). Each of these are FreeRTOS systems.</p>
<p><a class="reference internal" href="#../Getting_Started/Cygnus_Reach_Overview.pdf"><span class="xref myst">Here is a slide deck</span></a> that gives some introductory background.</p>
<section id="ecosystems">
<h2>Ecosystems<a class="headerlink" href="#ecosystems" title="Link to this heading">¶</a></h2>
<p>Let’s compare and contrast five Reach ecosystems that we are familiar with.</p>
<ul class="simple">
<li><p>SiLabs (BLE)</p></li>
<li><p>Nordic (BLE)</p></li>
<li><p>Microchip Harmony on PIC32WM_BZ6204 (AKA “BZ6”) (BLE)</p></li>
<li><p>RealTek BW16 (AmebaD) (BLE + MQTT)</p></li>
<li><p>Direct MQTT</p></li>
</ul>
<p>Each of these systems has its own unique communication stack.</p>
<section id="silabs">
<h3>SiLabs<a class="headerlink" href="#silabs" title="Link to this heading">¶</a></h3>
<p>SiLabs has no RTOS. It has limited code and data space. “User space” is split between a function called in the main loop and handlers for BLE stack events.</p>
</section>
<section id="nordic-zephyr">
<h3>Nordic/Zephyr<a class="headerlink" href="#nordic-zephyr" title="Link to this heading">¶</a></h3>
<p>Nordic uses the Zephyr (RT)OS. Reach runs in a task which communicates with the BLE stack callbacks from the BLE system. User space is mostly made up of code in a separate task. The existing examples are quite closely coupled to Reach.</p>
</section>
<section id="microchip-harmony">
<h3>Microchip Harmony<a class="headerlink" href="#microchip-harmony" title="Link to this heading">¶</a></h3>
<p>Harmony uses FreeRTOS. BLE support runs in an opaque task. Reach runs in its own thread which receives queued notifications from the BLE task. The BZ6 has plenty of code and data space. User space is in one or more other threads that have their own data structures. From the point of view of the “user space” code, Reach is being added to an existing system.</p>
</section>
<section id="realtek-bw16-amebad">
<h3>RealTek BW16 AmebaD<a class="headerlink" href="#realtek-bw16-amebad" title="Link to this heading">¶</a></h3>
<p>The RealTek AmebaD similarly uses FreeRTOS. While “user space” code can be built onto the part (it has plenty of memory), it is treated here as a “Reach CoProcessor” (RCP). The user space host processor connects to the Reach CoProcessor by a serial port.</p>
</section>
<section id="direct-mqtt">
<h3>Direct MQTT<a class="headerlink" href="#direct-mqtt" title="Link to this heading">¶</a></h3>
<p>MQTT is used instead of using BLE to transmit data to and from a cloud host.</p>
</section>
</section>
<section id="reach-overview">
<h2>Reach Overview<a class="headerlink" href="#reach-overview" title="Link to this heading">¶</a></h2>
<p>Reach should be integrated into your app as three submodules.</p>
<ul class="simple">
<li><p><strong>Reach C Stack</strong> — The “library”</p></li>
<li><p><strong>Protobuf</strong> — The “interface” shared with the Cygnus app and tools.</p></li>
<li><p><strong>Utils</strong> — Contains a python script to generate the Reach data structures based on a JSON format description.</p></li>
</ul>
<p>Further there will be an <strong>Integrations</strong> directory that connects the Reach stack to the communication facilities (BLE stack, etc.) of your platform.</p>
<p>The code generation python script found in the utils directory is applied to a JSON format description of your project to produce a boiler plate version of the code to support your product. You must then extend this code with product specific code to do things like actually read the data that parameters use. The generated code uses comments to delineate the start and end of user code that is preserved when the code is regenerated.</p>
</section>
<section id="porting-steps">
<h2>Porting Steps<a class="headerlink" href="#porting-steps" title="Link to this heading">¶</a></h2>
<p>The task can be broken down into a few key steps.</p>
<ol class="arabic simple">
<li><p>Explore the (BLE) interface</p></li>
<li><p>Advertise Reach</p></li>
<li><p>Integrate i3_log()</p></li>
<li><p>Respond to Get Device Info</p></li>
<li><p>Complete the Reach port</p></li>
</ol>
</section>
<section id="explore-the-ble-interface">
<h2>1. Explore the (BLE) Interface<a class="headerlink" href="#explore-the-ble-interface" title="Link to this heading">¶</a></h2>
<p>Reach includes an “integrations” layer that is designed to be customized to the current platform. The <strong>Integrations</strong> directory typically includes a subdirectory for this particular platform. This code is designed to be reused in multiple projects using the platform. The separate subdirectories allow us to distribute a package with multiple integrations, but the integration directory is committed with the specific project. Reach was originally designed and optimized for use over BLE but it can function over other interfaces.</p>
<p>The code in the integrations directory connects Reach to the native features on the platform. You can refer to existing integrations and reuse as much as is convenient. Here we assume you are working on a new platform. The first step is to understand how the native features work.</p>
<section id="ble">
<h3>BLE<a class="headerlink" href="#ble" title="Link to this heading">¶</a></h3>
<p>When a Reach device is a peripheral, it uses one service and one characteristic. Reach needs to be able to receive data written to a characteristic and it needs to notify the central device with changed data. Reach relies on BLE 4 generation MTU lengths of 247 bytes.</p>
<ul class="simple">
<li><p>Configure your device to advertise a service and use LightBlue or nRF Connect to receive data written by the central.</p></li>
<li><p>Configure your device to enable notifications on this characteristic and then demonstrate that you can notify the central with data.</p></li>
<li><p>Prove that the data packet (MTU) can be as large as 247 bytes.</p></li>
</ul>
</section>
<section id="mqtt">
<h3>MQTT<a class="headerlink" href="#mqtt" title="Link to this heading">¶</a></h3>
<p>MQTT transport of Reach has been explored but it has not yet been productized. When a device uses an MQTT interface it publishes and subscribes to one topic.</p>
<ul class="simple">
<li><p>We have not defined a standard topic name for Reach topics.</p></li>
<li><p>Prove that you can publish on this topic and be notified by a subscription.</p></li>
<li><p>We will want to use QoS that guarantees each message is delivered once.</p></li>
<li><p>Be sure to check that the message is delivered.</p></li>
</ul>
</section>
</section>
<section id="advertise-reach">
<h2>2. Advertise Reach<a class="headerlink" href="#advertise-reach" title="Link to this heading">¶</a></h2>
<section id="id1">
<h3>BLE<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<p>Reach requires your device to advertise a service with a specified 128 bit UUID. This is specified in the Reach Programmers Introduction on github. Reach requires this service to include one characteristic with a specified UUID. The Cygnus app will write (without confirmation) to this characteristic. The device will notify the central of data on this characteristic. The Cygnus app does not read except in the context of a notification.</p>
<p>The SiLabs Thunderboard advertises this raw data as captured by nRF Connect:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0x02010603030018110730F940B6BF89A2A6C24EB3796992D5ED1B095265616368657220233200
</pre></div>
</div>
<p>This decodes as:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Type</p></th>
<th class="head"><p>AD Type</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Flags</p></td>
<td><p>0x01</p></td>
<td><p>0x06</p></td>
</tr>
<tr class="row-odd"><td><p>16-bit UUID</p></td>
<td><p>0x03</p></td>
<td><p>0x1800 (Generic Access)</p></td>
</tr>
<tr class="row-even"><td><p>128-bit UUID</p></td>
<td><p>0x07</p></td>
<td><p>ED D5 92 69 79 B3 4E C2 A6 A2 89 BF B6 40 F9 30</p></td>
</tr>
<tr class="row-odd"><td><p>Local Name</p></td>
<td><p>0x09</p></td>
<td><p>“Reacher #2”</p></td>
</tr>
</tbody>
</table>
<p>Formatted in C:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">advPayload</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="mh">0x01</span><span class="p">,</span><span class="w"> </span><span class="mh">0x06</span><span class="p">,</span><span class="w">                          </span><span class="c1">// Flags</span>
<span class="w">    </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="mh">0x03</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">,</span><span class="w"> </span><span class="mh">0x18</span><span class="p">,</span><span class="w">                    </span><span class="c1">// 16-bit UUID: 0x1800</span>
<span class="w">    </span><span class="mi">17</span><span class="p">,</span><span class="w"> </span><span class="mh">0x07</span><span class="p">,</span><span class="w">                                </span><span class="c1">// 128-bit UUID</span>
<span class="w">        </span><span class="mh">0x30</span><span class="p">,</span><span class="w"> </span><span class="mh">0xF9</span><span class="p">,</span><span class="w"> </span><span class="mh">0x40</span><span class="p">,</span><span class="w"> </span><span class="mh">0xB6</span><span class="p">,</span><span class="w"> </span><span class="mh">0xBF</span><span class="p">,</span><span class="w"> </span><span class="mh">0x89</span><span class="p">,</span><span class="w"> </span><span class="mh">0xA2</span><span class="p">,</span><span class="w"> </span><span class="mh">0xA6</span><span class="p">,</span>
<span class="w">        </span><span class="mh">0xC2</span><span class="p">,</span><span class="w"> </span><span class="mh">0x4E</span><span class="p">,</span><span class="w"> </span><span class="mh">0xB3</span><span class="p">,</span><span class="w"> </span><span class="mh">0x79</span><span class="p">,</span><span class="w"> </span><span class="mh">0x69</span><span class="p">,</span><span class="w"> </span><span class="mh">0x92</span><span class="p">,</span><span class="w"> </span><span class="mh">0xD5</span><span class="p">,</span><span class="w"> </span><span class="mh">0xED</span><span class="p">,</span>
<span class="w">    </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mh">0x09</span><span class="p">,</span><span class="w">                                </span><span class="c1">// Complete Local Name</span>
<span class="w">        </span><span class="sc">&#39;R&#39;</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="sc">&#39;h&#39;</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="sc">&#39;r&#39;</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">,</span><span class="sc">&#39;#&#39;</span><span class="p">,</span><span class="sc">&#39;2&#39;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The SiLabs version manages to display these 10 characters for the name. The BZ6 version uses the scan response to advertise a long name.</p>
<p>When your advertisement satisfies the Cygnus app your device will be listed with the Cygnus icon.</p>
</section>
<section id="id2">
<h3>MQTT<a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<p>I don’t think this is necessary if the device is publishing and subscribing to the Reach topic.</p>
</section>
</section>
<section id="integrate-i3-log">
<h2>3. Integrate i3_log()<a class="headerlink" href="#integrate-i3-log" title="Link to this heading">¶</a></h2>
<p>The Reach stack is configured to supply a lot of diagnostic information via the printf-like i3_log() function. Any port should first support this to enable further debugging during bringup. The Reach C stack includes a weak implementation of the i3_log() functions that simply calls printf. If this works you can simply use it. In a multithreaded environment it makes sense to consistently protect i3_log() with a mutex so that it can be used reliably throughout the system. The BZ6 implementation satisfies this requirement.</p>
<p>I3_assert() should also be tested to prove that it stops and indicates its presence reliably both with the debugger (where it should stop and show the call stack) and without the debugger (where it should print an error message before halting).</p>
<p>These features are required to support the debugging features that Reach relies on. These debugging features can well be used by the user space code.</p>
</section>
<section id="respond-to-get-device-info">
<h2>4. Respond to Get Device Info<a class="headerlink" href="#respond-to-get-device-info" title="Link to this heading">¶</a></h2>
<p>With a proper advertisement and i3_log() ported you can bring in the Reach C stack and connect it to the BLE stack so that the Cygnus app (or web page) can discover the device. The host will issue a device information request. To respond to the request for device information you will need to:</p>
<ul class="simple">
<li><p>Define your device’s response using the code generation script in Utils to parse an appropriate JSON description.</p>
<ul>
<li><p>You can copy the JSON from a reference port and change something like the device name to see your handiwork.</p></li>
</ul>
</li>
<li><p>Receive the 19 byte request as a BLE write / MQTT subscription.</p></li>
<li><p>Feed the received data to Reach by calling cr_store_coded_prompt().</p></li>
<li><p>Run the cr_process() function in the Reach task to compose a response.</p></li>
<li><p>Call your implementation of crcb_send_coded_response() to notify the central of the result.</p></li>
</ul>
<p>The response to get device info (GDI) is on the order of 100 bytes, so it will fail if 247 byte MTU’s are not supported.</p>
<p>When this basic exchange is operating, what remains is to fill in things that are specific to your device.</p>
</section>
<section id="complete-the-reach-port">
<h2>5. Complete the Reach Port<a class="headerlink" href="#complete-the-reach-port" title="Link to this heading">¶</a></h2>
<p>The generated Reach code has places to add your own code. In a new project this user code will be empty. You can copy enough things to test from the reference code. For instance, the “commands” will all return “20” (not handled) until you put in handlers. You can copy these from the Thunderboard example. Eventually you will want to create reasonable handlers for each service and verify that they work correctly.</p>
<p>Note that there are init functions generated for each service. These need to be called before the service is accessed. When the parameter repo contains the name of the device, the parameter repo needs to be initialized before the communication stack.</p>
<section id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>You should see the names of the commands and pressing the buttons in the host interface you should see the action.</p></li>
</ul>
</section>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>You should see the list of parameters.</p></li>
<li><p>You should verify that you can read values and write values.</p></li>
</ul>
</section>
<section id="time">
<h3>Time<a class="headerlink" href="#time" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>You should verify that you can set the local time and read it back.</p></li>
</ul>
</section>
<section id="files">
<h3>Files<a class="headerlink" href="#files" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p>You should be able to upload something like a 50k file from the host and store it at /dev/null.</p></li>
<li><p>The debug mode of the Cygnus app measures the transfer rate which should ideally be north of 100k.</p></li>
</ul>
</section>
<section id="remote-cli">
<h3>(Remote) CLI<a class="headerlink" href="#remote-cli" title="Link to this heading">¶</a></h3>
<p>The CLI service includes a default command handler in cli.c. There are a couple of standard commands such as “help” and “ver” and “/”. You should connect this to the CLI of the device. Then when you enable the remote CLI (using a command) you should see the output of i3_log() at the host and commands from the host should flow to the device.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Cygnus Reach Embedded Stack</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Getting%20Started/index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programmers_guide/index.html">Programmer’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html">Porting Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API%20Reference/index.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Chuck Peplinski, Peter S. Jamrozinski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/Porting_guide/Porting_Guide.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>
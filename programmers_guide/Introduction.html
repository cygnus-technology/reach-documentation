<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Cygnus Reach Programmers Introduction &#8212; Cygnus Reach Embedded Stack  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=12dfc556" />
    <script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Porting Guide" href="../Porting_guide/index.html" />
    <link rel="prev" title="Programmer’s Guide" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p><img alt="alt_text" src="../_images/CygnusLogo_REACH-horiz-bg_light2.png" /></p>
<section id="cygnus-reach-programmers-introduction">
<h1>Cygnus Reach Programmers Introduction<a class="headerlink" href="#cygnus-reach-programmers-introduction" title="Link to this heading">¶</a></h1>
<p>I3 Product Design</p>
<p>Version     3.3</p>
<p>Date        June 6, 2024</p>
</section>
<section id="executive-summary">
<h1>Executive Summary<a class="headerlink" href="#executive-summary" title="Link to this heading">¶</a></h1>
<p>Cygnus Reach is a system to provide customer support to users of embedded IoT (Internet of Things) devices.  This support is also very useful to developers of such systems.</p>
<p>In case you aren’t familiar with Cygnus Reach, here are two links with some overview.</p>
<ul class="simple">
<li><p><a class="reference external" href="https://cygnustechnology.com/">https://cygnustechnology.com/</a></p></li>
<li><p><a class="reference external" href="https://cygnustechnology.com/see-reach-in-action/">https://cygnustechnology.com/see-reach-in-action/</a></p></li>
</ul>
<p>This package demonstrates the code in the device.  It’s a small part of the Cygnus ecosystem.  This document describes the design of the Cygnus Reach IoT device platform as implemented on a common Silicon Labs SoC.  A companion “Getting Started” document provides more introduction.</p>
<p>The Cygnus Reach concept has some history at i3 where it has been deployed in a series of products.  This version is effectively a rewrite from the ground up.  It is designed to be deployed more widely with less customization required.</p>
<p>The SDK’s necessary to develop customized mobile app and web pages for Reach access are available through your Cygnus sales representative.</p>
<section id="audience">
<h2>Audience<a class="headerlink" href="#audience" title="Link to this heading">¶</a></h2>
<p>This document is addressed to the embedded developer who is considering using the Cygnus Reach system in a product.  The authors assume that the audience has some familiarity with the Cygnus Reach concept.  Cygnus Reach includes features such as video and screen sharing that are quite independent from the embedded device. This document is about the embedded device portion of the system.</p>
</section>
<section id="version-history">
<h2>Version History<a class="headerlink" href="#version-history" title="Link to this heading">¶</a></h2>
<p>1.1 : January 8, 2024, first public release.</p>
<p>2.0:  February 9, 2024.  Adds features such as parameter notifications.  Provided with a separate release note.</p>
<p>3.0: March 12, 2024.  The directory structure of the code is changed to simplify maintenance.</p>
<p>3.1: March 20, 2024. Editing pass to reflectd the latest (stack 2.5) changes.</p>
<p>3.3: June 6, 2024: More overview.</p>
</section>
</section>
<section id="product-vision">
<h1>Product Vision<a class="headerlink" href="#product-vision" title="Link to this heading">¶</a></h1>
<p>The Reach stack enables the embedded system to be in contact with a mobile device over BLE for support and for development.</p>
<ul class="simple">
<li><p>Cygnus Reach is about supporting embedded devices.  The Cygnus Reach vision is to be a framework that is easily deployed into a range of products.  This requires several supporting components that are part of a larger ecosystem.</p></li>
<li><p>Customer support technicians are one user of Cygnus Reach.  But the product vision is for the Cygnus Reach device info interface to be of critical utility to the embedded developer.  Hence Cygnus Reach is not bolted on to an existing product but rather built in from the ground up.</p></li>
<li><p>The embedded developer must be able to expose the capabilities and debugging features of a device without creating a special web page.  The vision is to enable the embedded developer to construct the device info view without involving app or web developers.  This recommends a generic “display” client and an efficient data description mechanism.</p></li>
</ul>
</section>
<section id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Link to this heading">¶</a></h1>
<p>A typical Cygnus Reach system has at least two components:</p>
<ul class="simple">
<li><p>An embedded device acting as a “server” for its “device info” page.</p></li>
<li><p>A web page or an app with a rich user interface acting as a “client” to display the device info page.</p></li>
</ul>
<p>A mobile device may act as a “relay” to connect the embedded device to a web client.  The mobile device could also be the client on its own.</p>
<p>Bluetooth Low Energy (BLE) is most commonly used to communicate with the supported device, but other interfaces are possible if they are more appropriate.</p>
<p>The embedded server device and the display client must share a common language.  This is the Reach Protocol, described in a separate document. The interface is defined using “protobufs” to leverage the rich feature set supplied in multiple languages.</p>
<p>Reference implementations of embedded systems are available.  The Thunderboard demo runs on Silicon Labs very small BLE demo board.  The OpenPV reference version runs on an Enovation display.  Both talk to Android and iOS mobile devices.</p>
<p>The key features of the implementation include:</p>
<ul class="simple">
<li><p>Organization into pages that are convenient for users.</p></li>
<li><p>A standard way to identify the device and its firmware version(s).</p></li>
<li><p>A “parameter repository” to access control and status variables using a key-value pair model.</p></li>
<li><p>Access to a command line interface</p></li>
<li><p>A “file access” mechanism that supports high rate transfers of larger blocks of data.</p></li>
<li><p>A simple means to issue “commands” to the device.</p></li>
</ul>
<p>The three demo systems illustrate Reach on systems of different complexity.  The Linux based OpenPV displays from Enovation are an example of Reach in a sophisticated system.  The reach-silabs Thunderboard demo shows Reach with no OS as appropriate for tiny embedded systems.  The “reacher-nfc” demo shows Reach running on a Nordic development board.  Reach can certainly be deployed in everything in between, and there is ongoing development in other common systems.</p>
<p>The three system approach to support (device, phone, web page) is a key concept.  This acknowledges the three users in the system.  The product user has access to an embedded device as well as a mobile phone.  The support engineer uses a web browser so as to display data on a larger screen.  The embedded system designer is the third user, as the embedded system builder must include the support required.</p>
<p>A proper Cygnus Reach system design includes much input from customer support engineers.  The Cygnus Reach system exists to facilitate field support.  Hence the information presented to the support engineers must be what they need.  With new products the embedded system designer often has no customer support engineers available to provide design guidance.  Hence Cygnus Reach systems are often deployed in two phases.  The first phase exposes the things that the embedded system designer finds necessary.  The second phase tunes this to emphasize the things customer support needs to see first.</p>
<hr class="docutils" />
<section id="typical-interactions">
<h2>Typical Interactions<a class="headerlink" href="#typical-interactions" title="Link to this heading">¶</a></h2>
<p>A typical Reach session follows a pattern like this:</p>
<p><img alt="alt_text" src="../_images/typical.png" /></p>
<p>The exchange always begins with the client requesting device information.  The server replies.  The client can then request more information such as the parameter data.  The response packets are limited in size so as to fit in a Bluetooth Low Energ (BLE) packet.  The response may require several “continued” packets.  A subsequent section titled “Multi-Message (Continuing) Transactions” gives some more background on how continuing messages are handled.
The device information response tells the client what services are supported by the server.  The client can then request data from each service as necessary.</p>
<p>A number of design patterns used by Reach in multiple places.</p>
<ol class="arabic simple">
<li><p>The prompt-response pattern, where the server provides data in response to a prompt.</p></li>
<li><p>The discovery pattern, where the client discovers what the server can provide.</p></li>
<li><p>The continuing message pattern, where requested data is provided in several packets of size appropriate for the transport mechanism.</p></li>
<li><p>The notification pattern, where the server provides a message to the client without a prompt.</p></li>
</ol>
<p>This basis allows a simple system to deliver much utility.</p>
</section>
<hr class="docutils" />
<section id="bluetooth-low-energy-ble">
<h2>Bluetooth Low Energy (BLE)<a class="headerlink" href="#bluetooth-low-energy-ble" title="Link to this heading">¶</a></h2>
<p>The Reach protocol assumes that there exists a reliable underlying transport layer.  The protocol is initially deployed using the Bluetooth Low Energy transport protocol.  The implementation of the Reach stack is easily customized to fit the constraints of the available transport layer.</p>
<p>Reach is most commonly deployed over BLE.  Reach messages are configured to fit efficiently into the 244 byte limit on BLE packets.  Reach over BLE requires a single characteristic. When presented on a BLE interface, the following interface must be implemented. This standard allows for immediate recognition by and compatibility with a Cygnus capable app.</p>
<p><strong>REACH BLE Service:</strong></p>
<p>UUID: edd59269-79b3-4ec2-a6a2-89bfb640f930</p>
<p><strong>Characteristic:</strong></p>
<p>The single REACH API characteristic is all that is needed to enable access to the protocol. Client messages sent as individual characteristic writes and server responses are sent asynchronously as notifications.</p>
<table>
  <tr>
   <td><strong>Field</strong>
   </td>
   <td><strong>Description</strong>
   </td>
  </tr>
  <tr>
   <td>Name
   </td>
   <td>REACH API
   </td>
  </tr>
  <tr>
   <td>UUID
   </td>
   <td>d42d1039-1d11-4f10-bae6-5f3b44cf6439
   </td>
  </tr>
  <tr>
   <td>Type
   </td>
   <td>String
   </td>
  </tr>
  <tr>
   <td>Length
   </td>
   <td>Variable - up to max BLE APDU
   </td>
  </tr>
  <tr>
   <td>Properties
   </td>
   <td>Write, Read, Notify
   </td>
  </tr>
</table>
<p><strong>Advertisement:</strong></p>
<p>The BLE device must advertise this UUID so that mobile apps can identify it as a Cygnus device.  Note that the “Generic Access” service must also advertise to support long device names.</p>
<p><img alt="alt_text" src="../_images/SiLabsBLE.png" /></p>
<section id="other-transport-protocols">
<h3>Other Transport Protocols<a class="headerlink" href="#other-transport-protocols" title="Link to this heading">¶</a></h3>
<p>Reach can be implemented on other protocols.  MQTT and CAN are often discussed.  The CAN ecosystem includes a transport layer which is well suited to deliver Reach.  Reach over CAN would be appropriate to connect multiple Reach “endpoints” in a device.</p>
</section>
</section>
<section id="protobufs">
<h2>Protobufs<a class="headerlink" href="#protobufs" title="Link to this heading">¶</a></h2>
<p>The Reach communication protocol is implemented using Google’s open source “protobuf” tool.  The big advantage of this tool is how easily it is used on the client side where Reach devices are addressed using multiple high level languages like Kotlin, Swift, and C#.  All of these languages rely on garbage collection to support memory allocation.  Since C does not support garbage collection, we elect to use static buffers to implement the protobuf structures.</p>
<p>The reach.proto file is available on the cygnus-technology github site in the reach-protobuf repository.  The authors don’t expect users to modify the .proto file as it defines the communication standard.</p>
<p>We use nanopb to convert the .proto file into C structures. Following nanopb guidelines, we use a .options file to avoid the use of malloc(). All arrays are converted to fixed sizes which are set in the .options file. The .options file is generated using a python script, reach_proto\proto\preprocess_options.py. This reads in reach-c-stack/includes/reach_ble_proto_sizes.h and a prototype of the options file. It outputs an options file that reflects the sizes set by the device. The sizes here are optimized for efficient BLE transfer. A system that does not use BLE could adjust these sizes. The UI applications are designed to respect these size constraints that are advertised in the device info structure.</p>
</section>
<section id="system-structure">
<h2>System Structure<a class="headerlink" href="#system-structure" title="Link to this heading">¶</a></h2>
<p>The Thunderboard demo has two parts, namely a “server” written in C and a “client” written in Kotlin or Swift or typescript.  The demo server we describe here runs on a Silicon Labs (SiLabs) Thunderboard.  It advertises itself as a Reach device on BLE.  Android and iOS mobile apps are available as the demo client.  These are available in the corresponding play/app store.  Cygnus also supports a web client.</p>
<p>All of the Reach code, including demo applications for Silicon Labs and Nordic hardware platforms are available on the Cygnus Technology github site:</p>
<p>(<a class="reference external" href="https://github.com/cygnus-technology">https://github.com/cygnus-technology</a>)</p>
<p>The code can be seen as three parts.  The “app” is specific to the product, which is the demonstration by the reach-silabs program.  A protobuf module defines the Reach protocol and is shared with other systems.  The C language “Reach stack” (reach-c-stack) is reusable code that implements the Reach protocol with an appropriate interface to the app.  The entire set is built to port easily to other systems, whether in the SiLabs ecosystem or other BLE centric systems like those from Nordic.  The reach-silabs demo includes two files that target the SiLabs BLE interface.  These use a small and well defined interface to the rest of the stack.</p>
<p>How to build and run the demo is described elsewhere in the “Getting Started” document.</p>
</section>
<section id="porting-the-demo">
<h2>Porting the Demo<a class="headerlink" href="#porting-the-demo" title="Link to this heading">¶</a></h2>
<p>We encourage you to run the reach-silabs demo as is on the Thunderboard as it gives you a concrete reference.  This section outlines the process of porting the code to another system.  Here I assume it is a C project.</p>
<p>The SiLabs demo uses no RTOS.  Everything goes through an event loop which is part of the SiLabs BLE architecture.  The Nordic demo uses the Zephyr RTOS.</p>
<p>The recommendation in general is to bring up your application so that it behaves just like the Reach demo, and then go on to customize it for your own usage.  The rest of this document attempts to give some background to better understand the application.</p>
<p>The demo application can be configured to print out the “wire” traffic in the form of the bytes sent over BLE.  This can be a helpful reference when porting.</p>
<p>A similar demo version is available for the Nordic nRCS.  The Enovation Systems OpenPV platform also supports Reach.</p>
<section id="porting-tasks">
<h3>Porting Tasks<a class="headerlink" href="#porting-tasks" title="Link to this heading">¶</a></h3>
<p>The Getting Started document includes the necessary instructions if you are porting to a SiLabs system.  The following is a very general outline.  It’s helpful to consider the task of getting your device to respond to the Reach client in some isolation from the task of customizing you list of parameters and service.</p>
<ol class="arabic simple">
<li><p>Configure the BLE stack to advertise the Reach characteristic.</p></li>
<li><p>Begin by getting your BLE to work.  Get your system to advertise the Reach characteristic.</p></li>
<li><p>Next drop in the reach-c-stack folder.</p></li>
<li><p>The top level src and includes directories contain files that are designed to be customized for your application.  These are application specific implementations of the “weak” callback functions.  A couple of files have “silabs” in their names, and these connect the Reach stack to the BLE stack.  Other files like “params.c” implement what can be thought of as a dummy database which you can use for testing.</p></li>
</ol>
<p>Now that you are talking to the client you can focus on customizing the services to meet your needs.</p>
</section>
</section>
<section id="directory-structure">
<h2>Directory Structure<a class="headerlink" href="#directory-structure" title="Link to this heading">¶</a></h2>
<p>The “reach-silabs” project uses this top level directory structure.</p>
<section id="src-and-include-folders">
<h3>src and include folders<a class="headerlink" href="#src-and-include-folders" title="Link to this heading">¶</a></h3>
<p>The src and include folders at the top level of the project implement the callbacks that are required for the Reach stack to operate.  This includes application specific source files such as src/params.c which implements the callbacks required for cr_params.c.  There is generally a pair of files for each Reach “service,” one in the “app” and one in the stack.</p>
<p>The two silabs specific files (reach-silabs.c and silabs_cli.c) are also present here.</p>
<p>The include folder provides reach-server.h.  This is the compile time configuration file.  It #defines macros that enable or disable features of the system.</p>
</section>
<section id="reach-c-stack">
<h3>reach-c-stack<a class="headerlink" href="#reach-c-stack" title="Link to this heading">¶</a></h3>
<p>The directory (git submodule) “reach-c-stack” is designed to be used unchanged by multiple projects.  There is no “silabs” dependent code here.  All dependencies are to be satisfied by callback functions.  The sources are provided to help you understand and debug.  If you believe changes are appropriate, feel free to submit a ticket and a pull request on github.</p>
<ul class="simple">
<li><p>The reach-c-stack provides the portable core of reach.  A user should not have to change this.  It could be provided as a library but we choose to provide it in source form.</p></li>
<li><p>Reach source code is found in the “src” and “include” directories.</p></li>
<li><p>A “third_party” folder contains utilities from the open source web.</p></li>
<li><p>The reach-c-stack defines the “weak” functions that the app must implement.</p></li>
<li><p>It includes a logging function which relies on printf().</p></li>
<li><p>A “docs” directory includes the source for a web page which includes Doxygen generated API references.  This is accessible on the github site.</p></li>
<li><p>reach.pb.c and reach.pb.h are generated off of reach.proto.  The protobuf source file is available on the Cygnus github site in the public reach-protobuf repository.</p></li>
</ul>
</section>
</section>
<section id="application-structure">
<h2>Application Structure<a class="headerlink" href="#application-structure" title="Link to this heading">¶</a></h2>
<p>The Reach embedded system demonstrated here is written in C specifically to remain attractive to very small and simple embedded systems.  A number of design decisions follow from this.</p>
<ol class="arabic simple">
<li><p>The core Reach stack, which is provided by i3, should be reusable without changes on multiple platforms.</p></li>
<li><p>The core Reach stack relies on a set of callback functions that must be implemented by the target application.  We refer to these as “the weak functions” because they are implemented using the gcc “weak” feature.  This allows us to avoid the function pointers which add complexity to debugging.  These functions are prefixed with “crcb_”</p></li>
<li><p>Since C has no formal namespace support the reach stack uses prefixes when variables must be shared between files.  When possible variables are kept static, but the naming convention allows for functions to be isolated in files of reasonable sizes.</p></li>
<li><p>Malloc is not used.  Large data structures are not instantiated on the stack.  The buffers that are used to code and move data are statically allocated.</p></li>
<li><p>The .options features of nanopb are used to statically define the memory used for protobuf handling.</p></li>
<li><p>The .options file is generated using an H file.  This allows an application to change the buffer sizes.  The sizes are tuned for BLE.</p></li>
<li><p>A top level H file, “reach-server.h” defines many characteristics of the system that can be altered at build time.</p></li>
</ol>
</section>
<section id="event-loop-structure">
<h2>Event Loop Structure<a class="headerlink" href="#event-loop-structure" title="Link to this heading">¶</a></h2>
<p>From the point of view of an application designer, the reach code is all executed in a single “cr_process()” function which must be called with some regularity.  The process function will typically exchange one message with the client over BLE.  The process function is called with a tick count, which would typically be milliseconds since system start so that the reach stack can include support for timed notifications.  But the details of how this is implemented in the customers system are very flexible.  A system with an RTOS might run Reach in a task.  A system without an RTOS might call the process function in its loop.  The reach stack calls back into the application using the “weak” functions.  The embedded system must override these weak callback functions to provide the reach stack with what it needs.</p>
<p>The cr_process() function has nothing to do when the (BLE) communication link is not connecting the device and the client, so cr_process() returns and does nothing in this case.</p>
<section id="threading-concerns">
<h3>Threading concerns<a class="headerlink" href="#threading-concerns" title="Link to this heading">¶</a></h3>
<p>All traffic flows through the cr_process() function.  It is called from one thread.  Hence the Reach system is built to be single threaded and no mutex protection is necessary.  The remote CLI support adds some complexity in that it can produce data at any time.  This is why it uses separate communication buffers.</p>
</section>
<section id="feeding-data">
<h3>Feeding Data<a class="headerlink" href="#feeding-data" title="Link to this heading">¶</a></h3>
<p>Data can be pushed into the stack or pulled from the surrounding application.  The BLE code pushed coded data into the stack by calling cr_store_coded_prompt().  The socket based test harness overrides the implementation of crcb_get_coded_prompt() to accept data from a socket.  The weak default implementation of crcb_get_coded_prompt() assumes that cr_store_coded_prompt() has been called.</p>
<p>A similar dichotomy exists with the coded reply.  The socket based test app calls crcb_send_coded_response() which is overridden to send to a socket.</p>
</section>
</section>
<section id="client-server-architecture">
<h2>Client - Server Architecture<a class="headerlink" href="#client-server-architecture" title="Link to this heading">¶</a></h2>
<p>Reach generally states that the embedded device is a server and the phone is a client.  This implies that the server only responds to requests from the client.  The sort of asynchronous notifications required to support a remote command line go against this flow.  This has not been a problem in BLE systems, but when we test using a socket link we find that we must create a second socket pair oriented in the opposite direction.</p>
<p>An easy way to think about this is to consider the device as a server for most of the Reach protocol.  Notifications are an exception because there the device acts more like a client.  While the bulk of the Reach protocol is initiated by the mobile device as a client, notifications are initiated by the embedded device.  An easy way to handle this is to create an independent communication path for the notifications generated by the device.</p>
<p>Examples of “notifications” that come to the mobile device without prompt are:</p>
<ul class="simple">
<li><p>Error reports</p></li>
<li><p>Remote command line</p></li>
<li><p>Parameter notifications</p></li>
</ul>
</section>
</section>
<section id="on-logging">
<h1>On Logging<a class="headerlink" href="#on-logging" title="Link to this heading">¶</a></h1>
<p>Printf style logging and a command line interface are fundamental to embedded development.  The reach system relies on the logging support features that are documented here. The reach system provides a rich set of support for these features.  In addition to the serial port traditionally used, reach  supports a command line interface over the BLE connection.  Other solutions could be substituted if appropriate.</p>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Link to this heading">¶</a></h2>
<p>The authors worked off of this set of requirements for logging:</p>
<ol class="arabic simple">
<li><p>Users must be able to enable and disable logging on a per-function basis.  This must be configurable via the command line at run time.  Log calls are provided with a “mask” to serve this purpose.</p></li>
<li><p>“Levels” separate from masks are unnecessary.  The typical hierarchy of error, warn, debug, info, etc. is too limiting.  Masks take this place and masks must be per function.</p></li>
<li><p>A “\n” line ending is provided by default, but it must be possible to print into the buffer “bare” without this termination.  LOG_MASK_BARE allows for this.</p></li>
<li><p>Log entries classed as “error”, “warning” and “always” cannot be disabled by the mask.  Errors are printed red.  Warings are yellow.  Always is white.</p></li>
<li><p>Function and line are not included by default.  Users add them where appropriate.</p></li>
<li><p>Reach defines a set of masks that can be used to debug its internal functions.  Other mask bits are reserved to user applications.</p></li>
<li><p>It must be possible to turn off all logging at build time to minimize size.</p></li>
<li><p>It must be possible to access the CLI remotely.</p></li>
</ol>
</section>
<section id="implementation">
<h2>Implementation<a class="headerlink" href="#implementation" title="Link to this heading">¶</a></h2>
<p>All of this is supplied by i3_log.h/.c.  As provided, iI3_log.relies on printf.  This can be ported as necessary.  More information on the remote CLI is provided in a subsequent section.</p>
<p>The “lm” command (for log mask) enables the user to see more or less logging.  Commanding “lm” alone shows the settings.  The log masks are defined in i3_log.h:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span>  <span class="n">The</span> <span class="n">lowest</span> <span class="n">nibble</span> <span class="ow">is</span> <span class="n">reserved</span> <span class="n">to</span> <span class="n">system</span> <span class="n">things</span><span class="o">.</span>
<span class="c1">#define LOG_MASK_ALWAYS     0x01    // Cannot be suppressed</span>
<span class="c1">#define LOG_MASK_ERROR      0x02    // Prints red, cannot be suppressed</span>
<span class="c1">#define LOG_MASK_WARN       0x04    // Prints yellow, cannot be suppressed</span>
<span class="c1">#define LOG_MASK_BARE       0x08    // trailing \n is omitted</span>
<span class="c1">#define LOG_MASK_REMOTE     0x10    // Set this to indicate that a message should be shared remotely.</span>

<span class="o">//</span> <span class="n">These</span> <span class="n">used</span> <span class="n">by</span> <span class="n">Reach</span> <span class="n">features</span><span class="o">.</span>  <span class="n">Enable</span> <span class="n">them</span> <span class="n">to</span> <span class="n">debug</span> <span class="ow">and</span> <span class="n">understand</span><span class="o">.</span>
<span class="c1">#define LOG_MASK_WEAK       0x20    // print in weak functions</span>
<span class="c1">#define LOG_MASK_WIRE       0x40    // show what is on the wire</span>
<span class="c1">#define LOG_MASK_REACH      0x80    // show reach protocol exchanges</span>
<span class="c1">#define LOG_MASK_PARAMS     0x100</span>
<span class="c1">#define LOG_MASK_FILES      0x200</span>
</pre></div>
</div>
</section>
</section>
<section id="version-handling">
<h1>Version Handling<a class="headerlink" href="#version-handling" title="Link to this heading">¶</a></h1>
<p>All of the Reach components use the “semantic version” format (semver.org).  The component versions are provided as a string.  The device information structure includes a protocol_version string.  The device populates this with constants that are defined in the .proto file.</p>
</section>
<section id="on-memory-allocation">
<h1>On Memory Allocation<a class="headerlink" href="#on-memory-allocation" title="Link to this heading">¶</a></h1>
<p>The thunderboard reach system does not rely on malloc.  All memory allocation is static.  The protobuf system uses dynamic memory allocation in languages like Java that have garbage collection.  Using dynamic allocation in C puts the responsibility on the caller to free the memory and the authors wish to avoid this.</p>
<section id="memory-usage">
<h2>Memory Usage<a class="headerlink" href="#memory-usage" title="Link to this heading">¶</a></h2>
<p>The Reach thunderboard application version 3.1.9 was analyzed for memory usage by sorting the output of the “nm” tool.  These numbers are approximate, and they have certainly grown as we have added features.  The code was compiled with -Os for size.  These values are intended to give an order of magnitude overview of memory usage.  Consider in particular the memory requirements that scale with the number of parameters.</p>
<ul class="simple">
<li><p>The reach demo application takes up about 245k of flash memory with logging enabled.</p>
<ul>
<li><p>The “NO_LOGGING” macro reduces this by about 14k.</p></li>
</ul>
</li>
<li><p>The Reach demo code with protobufs occupies about 17k bytes in flash</p>
<ul>
<li><p>4500 bytes for the primary Reach library</p></li>
<li><p>2330 bytes for the callbacks.</p></li>
<li><p>5190 bytes for the protobuf library code</p></li>
<li><p>1988 bytes for the protobuf initialization data</p></li>
<li><p>1364 bytes for the Reach interface to the SiLabs BLE stack.</p></li>
<li><p>348 bytes for the i3 log functions</p></li>
<li><p>1920 bytes for the CLI functions</p></li>
</ul>
</li>
<li><p>Further flash describes parameters, commands and files:</p>
<ul>
<li><p>180 bytes per parameter</p></li>
<li><p>28 bytes per command</p></li>
<li><p>40 bytes per file</p></li>
</ul>
</li>
<li><p>Reach data requires about 2k in RAM, mainly for communication buffers.</p></li>
<li><p>Parameter values occupy 56 bytes of RAM each.</p></li>
</ul>
<p>Reach 3.3.0 consistently deployed #defines such as “INCLUDE_PARAMETER_SERVICE” for each optional service.  The difference in code size between all optional services included and all optional services excluded was about 22k (250k - 228k).</p>
<p>With Reach 3.5, the error reporting mechanism can be configured via a #define an additional 240 byte buffer can be allocated to support verbose message reporting to the client.</p>
</section>
<section id="communication-buffer-structure">
<h2>Communication Buffer Structure<a class="headerlink" href="#communication-buffer-structure" title="Link to this heading">¶</a></h2>
<p>Reach conceptually uses six buffers to exchange prompts and replies.  Each buffer is nominally 244 bytes, matching the BLE buffer size.  The third buffer points to the first buffer as it can easily be reused.  A further reduction of one buffer could be accomplished by encoding the payload directly into the outer message structure, but this makes the code rather confusing so this optimization is not shared.</p>
<ol class="arabic">
<li><p><strong>sCr_encoded_message_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Received encoded prompt message to be decoded.
</pre></div>
</div>
</li>
<li><p><strong>cr_ReachMessage sCr_uncoded_message_structure</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Contains the encoded prompt separated from the header.
 Also used for enccoding.
</pre></div>
</div>
</li>
<li><p><strong>sCr_decoded_prompt_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Decoded prompt to be processed.
 Reuses the sCr_encoded_message_buffer.
</pre></div>
</div>
</li>
<li><p><strong>sCr_uncoded_response_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Raw payload data to be encoded
</pre></div>
</div>
</li>
<li><p><strong>sCr_encoded_payload_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Payload encoded.
 The payload could be encoded directly into sCr_uncoded_message_structure saving a buffer at the cost of added complexity.  The encoded payload is currently copied into the **sCr_uncoded_message_structure**
</pre></div>
</div>
</li>
<li><p><strong>sCr_encoded_response_buffer</strong></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> Encoded message ready to be transmitted
</pre></div>
</div>
</li>
</ol>
<p>A separate pair of “ping pong” buffers are used to encode notifications.</p>
</section>
</section>
<section id="services">
<h1>Services<a class="headerlink" href="#services" title="Link to this heading">¶</a></h1>
<p>Reach devices advertise that they support a set of “services” such as “parameters”, “files” and “commands”.  Reach devices can implement as many or as few services as are appropriate.  Support for each service is segregated into separate files.</p>
<section id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Link to this heading">¶</a></h2>
<p>The file include/reach-server.h is designed to be used to configure your use of Reach.  Use #defines to include or exclude services.  reach-server.h also demonstrates #defines to configure the security of the Reach system.</p>
<section id="code-generator">
<h3>Code Generator<a class="headerlink" href="#code-generator" title="Link to this heading">¶</a></h3>
<p>There is ongoing work to create a code generator that will populate the product specific data.  The first generation of the examples wrote out this data by hand.  The current generation uses an experimental code generator with excel providing the front end.  This is helpful, but you can certainly choose to edit the configuration files by hand.</p>
</section>
</section>
<section id="device-information-service">
<h2>Device Information Service<a class="headerlink" href="#device-information-service" title="Link to this heading">¶</a></h2>
<p>The implementation of the crcb_device_get_info() callback function is generated in by the code generator and stored in definitions.c.  This overrides its weak prototype.  The device info service is required so this function is required.  The basic description of the product can be constant in flash but a copy is made so that parts can be overridden.  The device info request can include a “challenge key” as described in a following section about security.</p>
</section>
<section id="parameter-service">
<h2>Parameter Service<a class="headerlink" href="#parameter-service" title="Link to this heading">¶</a></h2>
<p>The implementations of the callback functions necessary to support the parameter repository are generated by the code generator and stored in definitions.c. Descriptions of parameters can be stored in flash with the variable data stored in RAM.  The demonstration code includes the storage of parameters in non-volatile memory (NVM).  The various callback functions used are all implemented here.  The Reach interface is designed to support product specific implementations of the parameter database.  The code generator exists to automate what the designers see as best practice.  The provided parameter repository is quite simple, but it has proved sufficient for many applications.</p>
<p>The parameter interface is designed to support small variables.  Byte arrays up to 32 bytes are supported.  Larger data blocks can be handled using the file service.</p>
<section id="parameter-notifications">
<h3>Parameter Notifications<a class="headerlink" href="#parameter-notifications" title="Link to this heading">¶</a></h3>
<p>Parameters can be configured to notify the client on change.  The configuration of notifications must be commanded each time a client connects to a device/server.  A notification is specified using three variables:</p>
<ul class="simple">
<li><p>Delta</p>
<ul>
<li><p>Delta specifies that the server will notify the client if the value changes by this much since the last reported change.</p></li>
</ul>
</li>
<li><p>Max period</p>
<ul>
<li><p>When the max period is set the server will generate a notification at this time even if no other change has happened.</p></li>
</ul>
</li>
<li><p>Min period</p>
<ul>
<li><p>The min period limits the frequency of rapidly changing things.  If you set the min period to 10 seconds and your parameter is crossing its delta hundreds of times per second you will only get a notification every 10 seconds.</p></li>
</ul>
</li>
</ul>
<p>These can be used together.</p>
<p>When the BLE connection is made and the reach stack is active the parameters that are configured for notification are read using the crcb_parameter_read() callback function in the main process loop (cr_process()).</p>
<p>Some items to keep in mind are:</p>
<ul class="simple">
<li><p>The number of parameters that can generate notifications is set by NUM_SUPPORTED_PARAM_NOTIFY in reach-server.h. Each notification requires another 56+20 bytes.</p></li>
<li><p>Parameters are only monitored when the BLE client is connected.</p></li>
<li><p>All parameter notifications are canceled when the client connects to the device. The client must enable all desired notifications when it connects.</p>
<ul>
<li><p>Notifications can be initialized on the device/server.</p></li>
<li><p>The client can discover the current configuration of notifications.</p></li>
<li><p>The client can efficiently change the configuration of notifications, as when a custom app displays various pages of information.</p></li>
</ul>
</li>
<li><p>Setting any of the notification parameters to zero means they will be ignored. Setting all of them to zero (delta, min, max) is the same as disabling that notification.</p></li>
<li><p>No delta applies for strings and byte arrays. They are checked for any change by strcmp() and memcmp() respectively.</p></li>
</ul>
</section>
<section id="access-control">
<h3>Access Control<a class="headerlink" href="#access-control" title="Link to this heading">¶</a></h3>
<p>The “challenge key” concept exists to allow different users different levels of access to the services and parameters.  Code in access.c supports a simple implementation of this.  The stack uses a function to check whether access is granted to specific objects.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">bool</span> <span class="n">crcb_access_granted</span><span class="p">(</span><span class="n">const</span> <span class="n">cr_ServiceIds</span> <span class="n">service</span><span class="p">,</span> <span class="n">const</span> <span class="n">int32_t</span> <span class="nb">id</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="command-service">
<h2>Command Service<a class="headerlink" href="#command-service" title="Link to this heading">¶</a></h2>
<p>The command service provides an easy way to execute simple functions not requiring parameters.  Commands can be described as having a long timeout which the client should respect.  The code generator generates the list of commands and the code to discover this list.  The device author must provide implementations to override the weak functions used by the stack.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">crcb_command_execute</span><span class="p">(</span><span class="n">const</span> <span class="n">uint8_t</span> <span class="n">cid</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="file-service">
<h2>File Service<a class="headerlink" href="#file-service" title="Link to this heading">¶</a></h2>
<p>The file service provides for the efficient transfer of larger blocks of data.  The file service only describes the transfer of data.  Callback functions must retrieve or store the data.  The example provides synthetic data.  The data associated with a file may or may not be stored in any formal file system.  This is entirely up to the device designer.</p>
</section>
<section id="cli-command-line-interface">
<h2>CLI (Command Line Interface)<a class="headerlink" href="#cli-command-line-interface" title="Link to this heading">¶</a></h2>
<p>The CLI service allows for debug access to aspects of the system that might not be deemed important enough for official support.  As embedded developers typically use the CLI, the authors have found that making this command line interface available to the support team often provides a necessary back to to solve real problems.  The CLI interface is made optional here via a define in reach_server.h.  The remote CLI echo is also disabled by default as it causes a lot of BLE traffic which can be confusing.</p>
</section>
<section id="time-service">
<h2>Time Service<a class="headerlink" href="#time-service" title="Link to this heading">¶</a></h2>
<p>The time service is designed to support setting and checking the time on devices that use a real time clock (RTC).  The time is represented by a 64 bit seconds field which should contain the UTC time in the Linux Epoch (since 1970).  The time also includes a “timezone” field which is a correction to the UTC time, also given in seconds.  The timezone field is optional, and so in theory timezones could be ignored, but we don’t recommend this for a collection or reasons that come up in development.</p>
</section>
<section id="wifi-service">
<h2>WiFi Service<a class="headerlink" href="#wifi-service" title="Link to this heading">¶</a></h2>
<p>The WiFi service is designed to let devices that include WiFi use an existing UI to connect to an access point.  The WiFi service is not yet fully supported.</p>
</section>
</section>
<section id="files-parameters-and-commands">
<h1>Files, Parameters, and Commands<a class="headerlink" href="#files-parameters-and-commands" title="Link to this heading">¶</a></h1>
<p>Parameters are supported using a simple key-value pair structure.  The decision to avoid dynamic memory allocation causes the parameter storage structure to have a fixed and limited size.  The limit is set to 32 bytes for a string.  Data that is too large for this is easily handled using the “file” construct.  Reach provides no formal file system.  Files can instead be thought of as a key-value pair in which the value size is limited only by the device-specific underlying implementation.  While the parameter structure is optimized to fetch several parameters together, the file structure is optimized to transfer a larger block of data as quickly as possible.  “Files” can be mapped to a file system if that is appropriate for the application.  They can also simply be larger blocks of data maintained by the app.</p>
<p>Commands provide a simple means to remotely trigger a function with fixed parameters.  Commands could always be implemented in other ways.  An example is the command to enable the remote CLI.  This can also be engaged using the command line, but providing a command makes it easier to get started with these features.</p>
<section id="multi-message-continuing-transactions">
<h2>Multi-Message (Continuing) Transactions<a class="headerlink" href="#multi-message-continuing-transactions" title="Link to this heading">¶</a></h2>
<p>The response to DISCOVER_PARAMETERS, and in fact to any “discover” command could extend over multiple “messages”.  To define terms:</p>
<ul class="simple">
<li><p>A _transaction is a series of messages.</p></li>
<li><p>A _message _has a _header _and a <em>payload</em>.</p></li>
<li><p>The _prompt _is a received payload.</p></li>
<li><p>The _response _is a generated payload.</p></li>
<li><p>When transferring a file there is a further entity known as the “<em>transfer</em>”.  The file (read) is a <em>transaction</em>.  It can be made up of a series of <em>transfers</em>, each terminated by an acknowledgement.</p></li>
</ul>
<p>The response to any “discover” message may require several messages to complete the transaction.  For this purpose the cr_process() function must call a handle_continued_transactions() function before looking for a new prompt.  The reach system must keep track of any continuing transactions.</p>
<p>Each discover handler first checks whether the request is null.  The request will be valid if this is a new request and it will be null if called for a repeating request.</p>
<p>The system stores a “continued_message_type” as well as at “num_remaining_objects”.  The handle_continued_transactions() function first looks at the continued_message_type.  It will be invalid when there is no continuing transaction.  If there is such a transaction pending the continued_message_type tells us what it is.  The appropriate handler function produces a payload which is encoded and we exit the cr_process() function with the encoded message.</p>
<p>The various messages in a multi-message transaction are tagged with the same transaction_id in their header.  This is helpful when checking for timeouts in the communication.  Each transaction has a defined timeout and its completion is easily determined.</p>
<p>File transfers are made in a series of transactions.  A transfer_id is included in the payload to tie this series of transactions together.</p>
</section>
<section id="read-file-sequence">
<h2>Read File Sequence<a class="headerlink" href="#read-file-sequence" title="Link to this heading">¶</a></h2>
<p>Reading a file exercises a sequence of transactions.  The sequence is tracked by a state structure in the stack.  The application must simply provide a function to read the data.</p>
<p>(Phone sends)     Transfer Init</p>
<ul class="simple">
<li><p>File ID, read/write, size, offset,</p></li>
<li><p>Messages per ACK, Transfer_id</p></li>
</ul>
<p>(device responds)         Transfer Init Reply  (error if not allowed)</p>
<p>Repeat:</p>
<p>(Phone sends)     Transfer Data Notification (SW CTS):</p>
<ul>
<li><p>Phone should be able to timeout.</p>
<p>(Device Responds)    (multiple) Transfer Data messages.</p>
</li>
<li><p>device sends N messages before waiting for an ACK.</p></li>
<li><p>Phone should be able to timeout.</p></li>
</ul>
<p>(phone sends)        Final Transfer Data Notification, with “is_complete” : true</p>
<p><img alt="alt_text" src="../_images/file_read_sequence.png" /></p>
</section>
<section id="write-file-sequence">
<h2>Write File Sequence<a class="headerlink" href="#write-file-sequence" title="Link to this heading">¶</a></h2>
<p>After the discover sequence, a file is written using a sequence of transactions.  All files are binary data.</p>
<p>(Phone sends)     Transfer Init</p>
<ul class="simple">
<li><p>File ID, read/write, size, offset,</p></li>
<li><p>Messages per ACK</p></li>
<li><p>Transfer_id</p></li>
</ul>
<p>(device responds)     Transfer Init Reply  (error if not allowed)</p>
<p>Repeat:</p>
<p>(Phone sends)     (multiple) Transfer Data messages.</p>
<ul>
<li><p>phone waits for an ACK after N messages.</p></li>
<li><p>Phone must be able to timeout if ACK is not received.</p>
<p>(device sends)     Transfer Data Notification (SW CTS):</p>
</li>
<li><p>OK, is_complete</p></li>
</ul>
<p><img alt="alt_text" src="../_images/file_write_sequence.png" /></p>
</section>
<section id="file-acknowledgement-rate-ack-rate">
<h2>File Acknowledgement Rate (ack_rate)<a class="headerlink" href="#file-acknowledgement-rate-ack-rate" title="Link to this heading">¶</a></h2>
<p>An “ack_rate” is specified for each file transfer.  This specifies the number of messages transmitted before an acknowledge is required.  A high ack_rate enables the highest possible data transfer rates over BLE. A low ack rate allows the system to efficiently respond to transmission errors.  In a BLE system, the BLE layer is already correcting errors, so high ack rates are appropriate.</p>
<p>The server finally decides the ack rate.  The client can request a different ack rate using the optional requested_ack_rate in the FileTransferRequest (formerly FileTransferInit) message.</p>
<ul class="simple">
<li><p>The requested_ack_rate is optionally sent by the client when requesting a file transfer.</p></li>
<li><p>The responding “ack_rate” is always present.</p></li>
<li><p>If the requested_ack_rate is provided, then the server should use it.</p>
<ul>
<li><p>The weak callback crcb_file_get_preferred_ack_rate() allows the application designer to choose this rate.</p></li>
<li><p>The server may confirm the requested ack_rate in its response.</p></li>
<li><p>The server may override the requested ack rate with its own preference if there is a good reason.  Ideally this reason would be communicated in the result_message field.</p></li>
</ul>
</li>
<li><p>If no requested_ack_rate is provided, the server will provide the ack_rate via the crcb_file_get_preferred_ack_rate() callback.</p></li>
</ul>
</section>
</section>
<section id="security">
<h1>Security<a class="headerlink" href="#security" title="Link to this heading">¶</a></h1>
<p>The Reach system relies on industry standards for security.  The BLE interface can easily be encrypted.  With the exchange of a key “out of band” the encryption is quite robust.  Reach-server.h contains #defines that configure the BLE interface.  The GATT database must also be configured appropriately.  “Level 2” protection can be achieved with devices that have no display.  Some sort of display or keypad is necessary to achieve “level 4” protection.</p>
<p>Reach supports access control in the the form of a “challenge key” which is presented when the client requests device info.  If the device is configured to require a challenge key and none is presented then a limited set of services will be visible to the client.  The device can be coded to support multiple challenge keys, each with its own level of access.</p>
<p>Basic access control is demonstrated with code in device.c and params.c.  Defining the macro DEMO_ACCESS_CONTROL sets up the “get device info” handler to require a challenge key.  Based on this challenge key matching expectation, the device presents more or less services.  The file params.c defines ACCESS_LEVEL_FULL as a bit that is or’ed into the access member of the parameter info structure to indicate that this parameter is only accessible at the “full” access level.</p>
<p>All of this code to handle access control is in the app and not in the reach stack.  You are quite welcome use these tools or invent your own to meet your needs.</p>
</section>
<section id="error-handling">
<h1>Error Handling<a class="headerlink" href="#error-handling" title="Link to this heading">¶</a></h1>
<p>Error reporting is considered important and hence Reach provides a method by which a textual error message can be delivered to the remote client.  The “Wisdom” command triggers a collection of more or less strange error reports for testing.  It can be quite helpful during development to allow device errors to be displayed at the client.  The extra 240 bytes of memory taken by the fully asynchronous error reporter can be eliminated with a #define in reach-server.h if necessary.</p>
</section>
<section id="endpoints">
<h1>Endpoints<a class="headerlink" href="#endpoints" title="Link to this heading">¶</a></h1>
<p>The top level Reach message structure includes an endpoint entry.  As this top level structure is for routing, we should use this to route messages to an endpoint.  The device info structure is intended to include a map listing the endpoints that are available here.  Endpoint zero contains this map.  The thunderboard system has only one endpoint.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Cygnus Reach Embedded Stack</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Getting%20Started/index.html">Getting Started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Programmer’s Guide</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Cygnus Reach Programmers Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#executive-summary">Executive Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#audience">Audience</a></li>
<li class="toctree-l3"><a class="reference internal" href="#version-history">Version History</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#product-vision">Product Vision</a></li>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#typical-interactions">Typical Interactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bluetooth-low-energy-ble">Bluetooth Low Energy (BLE)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#other-transport-protocols">Other Transport Protocols</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#protobufs">Protobufs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-structure">System Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#porting-the-demo">Porting the Demo</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#porting-tasks">Porting Tasks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#directory-structure">Directory Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#src-and-include-folders">src and include folders</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reach-c-stack">reach-c-stack</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#application-structure">Application Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#event-loop-structure">Event Loop Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#threading-concerns">Threading concerns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#feeding-data">Feeding Data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#client-server-architecture">Client - Server Architecture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#on-logging">On Logging</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#requirements">Requirements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#version-handling">Version Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#on-memory-allocation">On Memory Allocation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#memory-usage">Memory Usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#communication-buffer-structure">Communication Buffer Structure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#services">Services</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#configuration">Configuration</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#code-generator">Code Generator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#device-information-service">Device Information Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-service">Parameter Service</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameter-notifications">Parameter Notifications</a></li>
<li class="toctree-l4"><a class="reference internal" href="#access-control">Access Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#command-service">Command Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-service">File Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cli-command-line-interface">CLI (Command Line Interface)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-service">Time Service</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wifi-service">WiFi Service</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#files-parameters-and-commands">Files, Parameters, and Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#multi-message-continuing-transactions">Multi-Message (Continuing) Transactions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#read-file-sequence">Read File Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#write-file-sequence">Write File Sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-acknowledgement-rate-ack-rate">File Acknowledgement Rate (ack_rate)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#security">Security</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#endpoints">Endpoints</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Porting_guide/index.html">Porting Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../API%20Reference/index.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Programmer’s Guide</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Programmer’s Guide</a></li>
      <li>Next: <a href="../Porting_guide/index.html" title="next chapter">Porting Guide</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Chuck Peplinski, Peter S. Jamrozinski.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/programmers_guide/Introduction.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>